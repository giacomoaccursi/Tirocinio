[toc]



# Introduzione

Camminare è una delle attività più svolte quotidianamente. Una normale camminata richiede la coordinazione del sistema nervoso, muscoloelettrico e cardiorespiratorio. 
La camminata è influenzata dall'età, dall'umore e persino da fattori socioculturali. 
I disturbi dell'andatura portano ad una perdita della libertà personale, a cadute, seguite da possibili lesioni, e in generale ad una riduzione nella qualità della vita.[[1]](#1)
Negli anziani la velocità è un potente predittore della mortalità [[15]](#15).
L'attrezzatura e le metodologie utilizzate per l'analisi della camminata hanno fatto sostanziali progressi negli ultimi anni. Gli strumenti utilizzati permettono di diagnostiare in modo più efficiente e accurato coloro che hanno subito una lesione che influisce sulla loro capacità di camminare.  

Il campo della ricerca sull'andatura umana è ampio. Nel campo sanitario, poichè le anomalie nella camminata colpiscono un'alta percentuale della popolazione, l'andatura viene studiata per diagnosticare malattie neurodegenerative come il morbo di Parkinson, mielopatia, amiotrofia spinale, sclerosi multipla, atassia celebrale, tumori celebrali, alcuni tipi di demenza, malattie neuromusclari ecc..[[6]](#6)  

I sistemi tradizionali per la valutazione della camminata sono semi-soggettivi perchè sono svolti da specialisti che ne osservano la qualità facendo camminare il paziente. I risultati non si basano su rilevazioni oggettive ma su valutazioni soggettive. [[2]](#2)
Le nuove tecnologie hanno permesso agli specialisti di estrarre informazioni oggettive dalle diagnosi, riducendo quindi il margine di errore. 
I dispositivi utilizzati possono essere basati sia su sensori indossabili che non indossabili. 
I dispositivi basati su sensori non indossabili richiedono l'uso di strutture dedicate , il paziente cammina all'interno di una stanza e i suoi passi sono misurati attraverso sensori da pavimento. Uno dei problemi di questi sensori è il limitato numero di passi che possono essere compiuti e l'impossibilità di poterli usare durante le attività quotidiane. 
I dispositivi basati su sensori indossabili consentono invece di rilevare la camminata durante le attività quotidiane della persona, tuttavia, in alcuni casi possono risultare invasivi, alterando l'andatura e producendo misurazioni imprecise. 



## Sistemi attuali per l'analisi della camminata

Ad oggi i sensori indossabili costituiscono una alternativa meno complessa e costosa rispetto ai laboratori specializzati, in quanto il loro utilizzo non è limitato ad un ambiente controllato.  
Questi sensori sono attaccati a varie parti del corpo del paziente, ad esempio ai piedi o alla vita. Le caratteristiche temporali dell'andatura vengono raccolte e stimate da accelerometri e sensori di pressione all'interno delle scarpe, i segnali e i movimenti registrati possono essere utilizzati per l'analisi della camminata. 

### Goniometri

Vengono utilizzati per calcolare la rotazione fra due segmenti del corpo umano. Il goniometro basato su estensimetri lavora con una resistenza che cambia a seconda di quanto è flesso il sensore. Nel momento il cui viene flesso, la corrente al suo interno avrà un percorso più lungo e di conseguenza aumenterà la resistenza al suo interno proporzionalmente all'angolo di flessione. In generale questi dispositivi sono poco invasivi, facili da utilizzare e operano indipendentemente dall'asse sul quale ruotano le articolazioni. 

### Sensori Inerziali

Sono dispositivi che, attraverso accelerometri, giroscopi e qualche volta magnetometri, misurano la velocità di un oggetto, la sua accelerazione e l'orientamento. L'accelerometro usa i fondamenti delle leggi di Newton le quali dicono che l'accelerazione di un corpo è proporzionale alla forza netta che agisce su esso, quindi conoscendo il quoziente di proporzionalità (massa dell'oggetto) e tutte le forze misurate dai sensori, si riesce a calcolare l'accelerazione. Con l'integrazione dell'accelerazione troviamo la velocità, e integrandola otteniamo la posizione riferita ai 3 assi. Integrando la velocità angolare otteniamo l'angolo di flessione e attraverso algoritmi di filtraggio e classificazione possiamo estrarre il numero di passi fatti. [[2]](#2)
I vantaggi di tale sistema risiedono nella sua intrinseca portabilità, affidabilità e accuratezza. 
A differenza degli elettrogoniometri sono complessi e costosi, ma sono capaci di analizzare il movimento tridimensionale del cammino umano. 
La miniaturizzazione dei sensori inerziali permette di integrarli in solette che includono anche sensori di pressione per il rilevamento distribuito della forza plantare, moduli di comunicazione bluetooth e un sistema di ricarica induttiva[[2]](#2).

### Sensori ad Ultrasuoni

I sensori ad ultrasuoni vengono utilizzati per calcolare il passo corto, la lunghezza della falcata e la distanza fra i piedi. Le onde sonore emesse sono onde ad alta frequenza, al di sopra dello spettro udibile umano. 
Un sensore ad ultrasuoni calcola il tempo che intercorre tra l'invio e il ritorno dell'onda riflessa da un oggetto e, conoscendo la velocità con cui il suono viaggia nell'aria, calcola la distanza da esso. 
Qi et al [[3]](#3) ha proposto un metodo a basso costo, basato su questa tecnologia, per estrarre i parametri spazio-temporali dell'andatura, tra cui la velcità della falcata e la cadenza della falcata. Le prestazioni sono state valutate confrontando il sistema con un altro basato su una telecamera in laboratorio. I risultati mostrano la fattibilità della soluzione proposta, con un errore medio del 2.7%.  (aggiungere immagine del paper di riferimento)

### Sensori di forza e pressione

Entrambi i sensori si occupano di misurare la Ground Reaction Force (GRF), ovvero la forza di reazione esercitata dal suolo all'appoggio del piede. 
I sensori di pressione misurano solo le GRF verticali, mentre i sensori di forza misurano le GRF su ogni asse. 
L'uso più frequente che viene fatto di questi dispostivi è l'integrazione nelle scarpe. 
Alcuni studi, come quello di Howell et al [[4]](#4) hanno dimostrato che le misure ottenute da una soletta contenente 12 sensori capacitivi, mostrano un'alta correlazione con le misurazioni simultanee di un laboratorio di analisi del movimento. 
Esistono più scelte per quanto riguarda il tipo di sensore da utilizzare, la scelta dipende dalla pressione sopportata e dalla sensibilità: 

+ Sensori resistivi: la resistenza elettrica diminuisce all'aumentare del peso ai quali sono sottoposti. 
+ Sensori piezoelettrici: sono composti da 3 misuratori di deformazione, posti in 3 direzioni ortogonali. I misuratori sono collocati su un gel di silicone. Quando il gel sotto pressione si deforma, i misuratori ne misurano la deformazione e, conoscendo le caratteristiche del gel, può essere calcolata la pressione totale. 
+ Sensori capacitivi: si basano sul principio che la capacità del condensatore cambia in funzione di diversi parametri, la cui la distanza tra i due elettrodi.

### Sensori a pavimento

In questi sistemi i sensori sono collocati lungo il pavimento sulle "piattaforme di forza" [[3]](#3) dove l'andatura è misurata da sensori di forza o pressione.
Lo svantaggio principale di questi strumenti è la loro dimensione ridotta, che limita il numero di passi che si possono misurare. 
Leusmann et al [[5]](#5) hanno proposto il primo sensore integrabile nel pavimento di casa con l'obbiettivo di assistere le persone anziane e più fragili che vivono da soli. Il sensore funziona grazie ad una fitta rete di sensori piezoelettrici. L'algoritmo sviluppato raccoglie dati con il fine di valutare la camminata della persona, ma è in grado di rilevare anche eventuali cadute o situazioni di emergenza. 

### Sistemi commerciali

Esistono aziende che hanno sviluppato strutture per l'analisi dell'andatura ad alta precisione. I sistemi utilizzati sono basati su una varietà di sensori sia indossabili che non. Molti di essi utilizzano un alto numero di telecamere per riprendere l'andatura del paziente da più angolazioni. 
A differenza delle soluzioni citate finora, i sistemi in questione richiedono una grande quantità di attrezzatura e procedure di calibrazione che li rendono costosi sia in termini di tempo che di denaro e non sono applicabili alle situazioni della vita quotidiana. 
Nonostante queste limitazioni, per via della loro grande precisione, sono considerati i gold standard per le valutazioni cliniche e le nuove tecnologie proposte sono valutate confrontandole con questi sistemi. 



## Reti Neurali artificiali

Il modo più semplice per pensare all'Intelligenza Artificiale, al Machine Learning, alle Reti Neurali Artificiali e al Deep Learning è quello di pensare alle matrioske: ogni termine è un componente del termine precedente. 
Le reti neurali sono una branca del Machine learning (ML) che a sua volta è una branca dell'Intelligenza Artificiale (AI). 
Quando una rete neurale ha più di 3 layer, si parla di Deep Learning (DL). 

### Perceptron

Il primo modello matematico per un neurone artificiale è stato il Threshold Logic Unit proposto da Warren S.McCulloch e Walter H.Pitts Jr nel 1943.[[10]](#10).
Il modello presentato può essere descritto attraverso le seguenti regole: 

+ Un output binario y $\in$​​ {0, 1}, dove y = 1 inica che il neurone si attiva e y = 0 che il neurone è a riposo. 
+ Ha un numero N di ingressi binari eccitatori $X_k$ $\in$ {0, 1}
+ Ha un solo ingresso $i$. Se questo è acceso, il neurone non può attivarsi. 
+ Ha un valore di soglia $\Theta$. Se la somma dei suoi ingressi è maggiore di questo valore critico, il neurone si attiva, altrimenti rimane a riposo. 

Dato l'input $X = [X_1, X_2, X_3,...,X_n]$, l'input $i$, e il valore di soglia $\Theta$​, l'output è calolato come segue. 

$f(x)$​ = $\left\{ \begin{array}{rcl} {1} & se \sum X_k > \Theta & e &i = 0, \\ 0 & altrimenti \end{array}\right.$​

15 anni dopo il neurone di McCulloch e Pitts (MPC), Frank Rosemblat , ideò il perceptron, un miglioramento rispetto al MPC. 
Il principale contributo di Rosemblatt è stato quello di dimostrare che, rilassando alcune delle vecchie regole, in particolare l'uguale contributo di tutti gli ingressi e la loro natura intera, i neuroni artificiali potevano effettivamente imparare dai dati. 
I pesi, introdotti da Rosemblat determinano l'importanza di un determinato input rispetto all'output. 

$f(x) = \left\{ \begin{array}{rcl} {1} & se \sum X_k W_k> \Theta & e &i = 0, \\ 0 & altrimenti \end{array}\right.$

Rosemblatt ha anche ideato un primo algortmo che ha permesso al neurone artificiale di capire da solo i pesi corretti direttamente dai dati dati di addestramento. L'algoritmo può gestire solo classificazioni per classi linearmente separabili.

(Figura: separabili_nonseparabili, didascalia: si noti come in realtà l'esempio a destra possa essere trattato dal perceptron dopo una fase di preprocessing che lo riconduca ad un problema linearmente separabile)

(Figura: perceptron)

Nel 1969 Marvin Minsky e Seymour Papert pubblicarono il famoso libro Perceptrons: an introduction to computational geometry nel quale dimostravano quanto fosse limitato il perceptron di Rosemblat e qualsiasi altro perceptron a singolo strato, e in particolare, mostravano come non fosse in grado di imparare la semplice funzione logica XOR. 

### Reti neurali Artificiali

Una rete neurale artificiale è un paradigma di elaborazione ispirato al cervello umano. Una rete neurale artificiale è in grado di imparare e generalizzare dall'esperienza. Una delle principali aree nel quale è utilizzata è la previsione, ma trova spazio anche nella classificazione e nel riconoscimento di modelli. 
A differenza dei metodi statistici tradizionali, ha forme più generali e flessibili ed è in grado di eseguire una modellazione non lineare senza una conoscenza delle relazioni tra le variabili di input e di output. 
Una rete neurale con un singolo strato è un Perceptron. Un perceptron multi-strato è una rete neurale artificiale. 
Il ciclo di vita di una Rete Neurale Artificiale è divisa in due fasi, la prima è la fase di addestramento e l'altra la fase di predizione. 
Nella fase di addestramento si cercano i valori dei pesi e del bias. Nella fase di predizione invece, la rete neurale elabora l'input al fine di produrre previsioni. 
Il processo di apprendimento di una rete neurale è composto da una fase di andata e una di ritorno, rispettivamente chiamate Forward Propagation e Backward Propagation

#### Fase di addestramento

La fase di addestramento consiste nel trovare i giusti pesi per ogni strato della rete. 
Per controllare l'output di una rete neurale occorre misurare quanto quell'output è lontano dal risultato aspettato. Questo è il ruolo della funzione di costo. La funzione di costo calcola la distanza fra l'output atteso e l'output predetto, rivelando in tal modo quanto la rete è stata addestrata bene in quello specifico caso [[14]](#14).
Il punteggio ottenuto viene utilizzato come feedback per aggiustare i pesi, con lo scopo di minimizzare la perdita. 
Questo aggiustamento viene fatto tramite l'uso dell'algoritmo di backpropagation.
Inizialmente, i pesi nella rete vengono inizializzati con numeri casuali. Ovviamente in questo primo momento, gli output saranno lontani dai risultati sperati e il punteggio di perdita sarà molto alto. 
Man mano che la rete elabora i dati di training, i pesi vengono aggiustati. Il ciclo di addestramento viene ripetuto un numero di volte tale da ridurre la funzione di perdita. 
Se la rete è stata addestrata correttamente, i suoi output saranno il più vicino possibile ai risultati reali. 

### Forward Propagation

Come suggerisce il nome, i dati input vengono elaborati in avanti attraverso la rete. Ogni strato nascosto accetta i dati in input, li elabora a seconda della propria funzione di attivazione e li passa allo strato successivo. 
Per generare un output, i dati devono obbligatoriamente fluire solo in avanti. Se fluissero anche all'indietro si formerebbe un ciclo e nessun output sarebbe generato. 
In ogni neurone dello strato nascosto o di uscita, l'elaborazione avviene in due fasi: 

1. Preattivazione: viene effettuata una somma pesata di tutti i valori in input e viene aggiunto un bias. 
2. Attivazione: la somma pesata degli input è passata alla funzione di attivazione. La funzione di attivazione aggiunge non linearità alla rete. 

Sulla base del risultato ottenuto, il neurone decide se inoltrare le informazioni al neurone successivo. 

### Activation functions

Quando un neurone calcola la somma pesata degli input e aggiunge un bias deve decidere se attivarsi o meno. Considerando un neurone: $ Y = \sum(weight * input) + bias$​​​. 
Il valore di $Y$​​​​ pu​ò essere qualunque valore nel range $(-inf  ,+inf$​​​​​​), la funzione di attivazione consente al neurone di capire se attivarsi o no. 

#### Step Function

E' la funzione di attivazione più semplice. Se $Y$​​ è superiore ad una certa soglia, il neurone si attiva, altrimenti rimane a riposo. 
Il problema principale di questo approccio è il fatto che si possono trovare più neuroni di output attivati con valore 1, che non consentono di capire quale sia la classe predetta. 
Una rete con queste caratteristiche è difficile da addestrare e porta a problemi di convergenza.

#### Sigmoid Function

$$f(x) = \frac{1}{1 + e^{(-x)}}$$​​​​​​​ .

E' una funzione matematica a forma di S. Viene utilizzata quando si necessita di un classificatore che risolva problemi con più di una risposta esatta. La funzione sigmoide ritorna per ogni input un valore compreso fra 0 e 1. 
Il problema principale di questa funzione è che ha una derivata a corto raggio che porta ad una perdita di informazioni. In particolare se nella rete neurale ci sono più strati, più dati vengono compressi e persi in ciascun strato traducendosi in una significativa perdita di dati nel complesso. 

#### Softmax Function

$$f(x_i) = \frac{e^{Z_i}}{\sum_{i}{e^{x_i}}}$$​​ 
E' una funzione di attivazione che prende in input un vettore di numeri reali e li normalizza in una distribuzione di probabilità proporzionale agli esponenziali dei valori in input. 
I valori di output avranno un valore compreso fra 0 e 1 e la loro somma sarà uguale ad 1.  
E' simile alla funzione sigmoide, la differenza sostanziale è che la funzione sigmoide produce output indipendenti.

#### Tanh Function

$$f(x) = \frac{2}{1 + e^{-2x}} - 1  = 2·sigmoid(2x) -1 $$   
E' una funzione sigmoide scalata. I valori di output sono nel range (-1, 1), le derivate sono più ripide rispetto alla sigmoide.

#### ReLu (Rectified Linear Activation Function)

$$f(x) = max(0, x)$$​​​​
La funzione ReLu restituisce valori positivi se l'input è positivo, 0 altrimenti. 
Nelle reti con funzioni di attivazione tanh o sigmoide, l'attivazione dei neuroni sarà di tipo denso poichè quasi tutti i neuroni saranno attivati. Con la funzione ReLu, invece, quasi il 50% della rete non produce attivazioni, grazie al fatto che ReLu restituisce valore 0 per input negativi. 
Un minor numero di attivazioni si traduce in una rete più leggera.
Il problema principale è che i valori negativi diventano 0 immediatamente, questo fatto riduce l'abilità del modello di allenarsi sui dati a disposizione, per questo motivo sono state implementate alcune varianti di ReLu come ad esempio Leaky ReLu, che restituisce $y = 0.01x$ per $x < 0$.


### Backward Propagation

E' probabilmente una delle colonne portanti delle reti neurali. E' stata introdotta per la prima volta nel 1970 e poi riscoperta nel 1989 da Rumelhart, Hinton and Williams [[11]](#11). 
E' un algoritmo per il supervised learning di reti neurali artificiali che utilizza la discesa del gradiente. 
La discesa del gradiente ha come scopo la scoperta del minimo locale di una funzione, muovendosi iterativamente nella direzione opposta al gradiente della funzione nel punto corrente. 
Il calcolo del gradiente viene fatto procedendo all'indietro nei nodi della rete. I calcoli parziali del gradiente in uno strato sono riutilizzati nel calcolo per lo strato precedente. Questo flusso all'indietro ne permette un calcolo efficiente.

#### Discesa del gradiente

Esistono 3 varianti della discesa dell gradiente, le quali si differenziano per il numero di dati utilizzati per calcolare il gradiente della funzione. 

##### Batch Gradient Descent

Calcola il gradiente della funzione per i parametri $\Theta$ sull'intero training set. 
$$ \theta = \theta - η · \grad_{\theta}J(\theta)$$

Questa tecnica può risultare molto lenta e diventa impraticabile nel caso in cui il dataset non si adatta alla memoria. 

##### Stochastic gradient descent

Esegue un aggiornamento dei parametri per ogni dato di training $x^{(i)}$ e label $y^{(i)}$
$$ \theta = \theta - η · \grad_{\theta}J(\theta;\ x^{(i)}; \ y^{(i)})$$

Batch gradient descent esegue calcoli ridondanti per grandi insiemi di dati, poichè ricalcola i granienti per esempi simili prima di ogni aggiornamento dei parametri. 
SGD elimina questa ridondanza eseguendo un aggiornamento alla volta. Gli aggiornamenti sono frequenti e ad alta varianza, causano per questo una fluttuazione pesante alla funzione obiettivo. 
A differenza del batch gradient descent, che riesce a trovare minimi solo del bacino nel quale sono collocati i dati, SGD, grazie alla sua fluttuazione riesce a saltare verso nuovi minimi locali. D'altra parte questo complica la convergenza ad un minimo esatto. Tuttavia, è stato dimostrato che diminuendo lentamente il learning rate, converge sicuramente ad un minimo locale in caso di funzione non convessa, o ad un minimo globale in caso di funzione convessa. 

##### MiniBatch Gradient Descent

Combina le due tecniche precedenti, eseguendo un aggiornamento per ogni mini-batch di n esempi di training. 
$$ \theta = \theta - η · \grad_{\theta}J(\theta;\ x^{(i\ :\ i+n)}; \ y^{(i\ :\ i+n)})$$
Riducendo la varianza degli aggiornamenti si ottiene una convergenza più stabile. 
E' l'algoritmo più utilizzato nelle reti neurali. 

### Feed Forward Neural Network

Le reti Feed Forward sono uno dei modelli più antichi. Questo approccio è stato usato per la prima volta negli anni 50.  All'interno di queste reti, le informazioni viaggiano solo in avanti, non esistono collegamenti all'indietro o sul nodo stesso. La rete contiene uno strato nascosto, che collega lo strato di input e quello di output. Tutti i nodi sono fortemente connessi.  

### Recurrent Neural Network

Le reti neurali ricorrenti sono una classe di reti neurali utili per modellare sequenze di dati o serie temporali. Sono molto utlizzate per problemi di traduzione della lingua, natural language processing, riconoscimento del parlato e completamento del testo. Si distinguono dalle reti Feed Forward per la loro memoria, in quanto prendono informazioni dagli input precedenti per influenzare l'input e l'output attuali.
Un'altra caratteristica che distingue le reti ricorrenti è che condividono i parametri tra ogni strato della rete. Sfruttano l'algoritmo di backpropagation through time (BPTT), leggermente diverso dall'algoritmo di backpropagation tradizionale, il quale somma gli errori ad ogni passo temporale. 
Proprio per questa loro peculiarità, le reti ricorrenti tendono ad incorrere in due problemi, noti come gradiente esplosivo e gradiente in dissolvenza. Quando il gradiente è troppo piccolo, continua a diminuire, aggiornando i pesi finchè non diventano nulli. Quando accade ciò, l'algoritmo non sta più imparando. 
Il gradiente esplosivo si verifica quando il gradiente è troppo grande, i pesi del modello cresceranno troppo e il modello diventerà instabile. 
Una delle soluzioni più adottate è ridurre il numero di strati nascosti, eliminando quindi una parte della complessità. 

#### LSTM

Le reti neurali ricorrenti hanno una memoria corta. Le reti Long short-term memory sono estensioni delle reti ricorrenti che permettono di estenderne la memoria e a ricordare quindi un input per lunghi periodi di tempo. 
Le informazioni vengono memorizzate in una memoria, nella quale i dati possono essere letti, scritti o eliminati.  
La memoria può essere vista come un cancello, che decide se salvare le informazioni in base all'importanza assegnata ad esse. L'assegnazione dell'importanza avviene tramite i pesi appresi dall'algoritmo. 
In una LSTM abbiamo tre cancelli: 

+ Input Gate, decide se far entrare o meno un nuovo input
+ Forget Gate, decide se cancellare o meno una informazione
+ Output Gate, decide se il dato debba avere un impatto sull'output al momento attuale. 

I cancelli sono analoghi nella forma alle sigmoidi, l'output restituito sarà sempre compreso fra 0 e 1. 

### Convolutional neural network

Una rete convoluzionale è una rete neurale artificiale capace, data una immagine in input, di assegnare un peso ai vari oggetti/aspetti presenti e di differenziarli l'uno dall'altro.
Prima delle CNN, per identificare oggetti all'interno delle immagini si utilizzavano metodi di estrazione delle caratteristiche manuali e dispendiosi in termini di tempo. Le reti convoluzionali moderne forniscono un approccio maggiormente scalabile sfruttando i principi dell'algebra lineare, in particolare moltiplicazione di matrici. Per effettuare queste operazioni in tempi brevi, occorre utilizzare le GPU. 
Sono composte di tre layer principali: 

- Layer Convoluzionali
- Pooling Layer 
- Layer densamente connessi (Dense Layer)

Oltre a questi vengono anche utilizzati layer di Dropout e Flatten. 



#### Dense layer

Utilizza un insieme lineare di connessioni tra l'input e l'output. Tutti i neuroni di uno dense layer sono connessi a tutti i neuroni dello strato successivo. In questo modo ogni unità prende l'input da tutte le unità precedenti e lo trasferisce a quelle successive. 
Questo porta a un calcolo matrice-vettore molto semplice, ma anche ad un insieme molto grande di parametri addestrabili. 
Reti neurali composte da layer densi sono utili per dati a bassa dimensione, mentre i calcoli possono diventare molto onerosi nei casi in cui i dati sono ad alta dimensione, come nel caso delle immagini. 

#### Convolutional layer

Uno strato convoluzionale contiene un insieme di filtri i cui parametri devono essere appresi. L'altezza e il peso dei filtri sono più piccoli di quelli del volume di input. Il filtro viene fatto scorrere attraverso la larghezza e l'altezza dell'input e in ogni posizione viene calcolato il prodotto scalare fra l'input e il filtro per creare una mappa di attivazione fatta di neuroni. L'output di uno strato convoluzionale è ottenuto impilando le mappe di attivazione di tutti i filtri. 
Poichè la larghezza e l'altezza di ogni filtro è progettata er essere più piccola dell'input, ogni neurone nella mappa di attivazione è collegato solo ad una piccola regione locale dell'input [[12]](#12).
Questa soluzione è ispirata alla corteccia visiva animale, dove i campi recettivi delle cellule sono molto piccoli. 
La connettività locale dello strato convoluzionale consente alla rete di imparare filtri che corrispondono a una regione locale dell'input, questa possibilità è molto importante dal momento che data un'immagine in input, un pixel è più correlato ai pixel vicini rispetto a quelli lontani. 

#### Pooling Layer

Simile allo strato convoluzionale, il pooling layer è responsabile della riduzione della dimensione spaziale, utile per diminuire la potenza di calcolo richiesta per elaborare i dati. Esistono due tipi di pooling: Max Pooling e Average Pooling. 
Il Max Pooling restituisce il valore massimo dalla porzione di immmagine coperta dal filtro. 
L'Average Pooling restituisce la media di tutti i valori della porzione di immagine coperta dal filtro. 
Average Pooling si limita ad eseguire una riduzione della dimensionalità, mentre Max Pooling funziona anche come soppressore del rumore, scartando del tutto le attivazioni rumorose.
Il Pooling Layer è spesso incorporato fra due strati convoluzionali successivi. 

#### Dropout Layer

Dropout è un metodo per la regolarizzazione nelle reti neurali artificiali. L'idea chiave è quella di disabilitare alcune unità di input in modo totalmente casuale durante la fase di training. 
In ogni fase dell'addestramento, i singoli nodi vengono eliminati dalla rete con probabilità 1 - p o mantenuti con probabilità p. Anche i nodi di input e output possono essere rimossi. 
Questa tecnica riduce significativamente l'overfitting e fornisce miglioramenti significativi rispetto ad altri metodi di regolarizzazione. 
Qualche considerazione sul dropout: 

1. Il dropout costringe una rete neurale ad apprendere caratteristiche più robuste che sono utili in combinazione con molti sottoinsiemi casuali diversi degli altri neuroni
2. Il dropout raddoppia approssimativamente il numero di iterazioni richieste per convergere. Tuttavia il tempo di addestramento per ogni epoca è inferiore. 
3. Con H unità nascoste che possono essere eliminate, abbiamo $2^H$​​ ​modelli possibili. 



#### Flatten Layer

Lo strato flatten serve a rimuovere tutte le dimensionalità eccetto una. In altre parole, partendo da una matrice, viene creato un array unidimensionale. 
Se l'ultimo strato convoluzionale restituisse in output un tensore (28, 28, 3), applicando il flattening avremmo un tensore (2532, 1). 

### Overfitting e Underfitting

Un algoritmo di successo deve performare bene anche su dati di input mai analizzati dello stesso tipo di quelli proposti nel training set e validation set. Le performance di un algoritmo non devono essere valutate solo sulla capacità nel minimizzare l'errore nel training, ma anche nel minimizzare la differenza tra gli errori di training e validation. Quest'ultima differenza viene anche chiamata errore di generalizzazione. 
L'errore di generalizzazione e l'errore sul training dipendono dalla capacità di rappresentazione, la quale è una misura di quanto l'algoritmo è in grado di adattarsi a una gamma di ouput. 

In teoria, se la capacità di rappresentazione può essere arbitrariamente alta, l'algoritmo si adatterà perfettamente ad ogni insieme finito di eventi, ma questo limiterà la sua capacità di funzionare bene su nuovi dati, poichè si sarà eccessivamente specializzato sui dati di addestramento. 

Quando un algoritmo è in grado di rendere piccolo l'errore sui dati di addestramento ma perde la capacità di generalizzare, siamo di fronte ad overfitting.
Viceversa, quando un algoritmo è caratterizzato da un'alto bias e una bassa varianza, non riesce a minimizzare l'errore nei dati di addestramento, siamo di conseguenza di fronte ad underfitting. 
(figura: underfitting_overfitting, didascalia: nella parte sinistra dell'immagine possiamo notare come l'erorre nel training e l'errore di generalizzazione siano entrambi alti, siamo infatti nella zona di underfitting. Incrementando la capacità, l'errore sul training diminuisce, ma aumenta il gap fra errore di training e di generalizzazione. Spostandosi verso destra, il divario aumenta e si entra nella zona di overfitting, dove a capacità è troppo grande, al di sopra della capacità ottimale [[8]](#8))



## Acquisizione dei dati 

Quando si parla di dataset contenenti video di persone che camminano, bisogna distinguere quelli utilizzati per il riconoscimento della camminata da quelli utilizzati per analisi medica. 
Online si trovano diversi dataset per il riconoscimento della camminata, mentre è molto più difficile trovarne adatti all'analisi medica. I gruppi di ricerca che ne possiedono, difficilmente li condividono online, a causa dei problemi etici e di privacy. 
I pochi dataset che sono stati utilizzati per l'analisi della camminata non forniscono i video o le immagini ma solo le silhouettes, le quali possono presentare anche errori di segmentazione. 
La decisione è stata quella di creare autonomamente il dataset. 
Il dataset creato è composto da 322 video della durata media di 6/7 secondi, nel quale il soggetto cammina parallelamente alla telecamera in avanti e poi torna indietro. 
Le camminate possono essere di tre tipi: 

+ Normale (106 video)
+ Lievemente Anormale (113 video)
+ Fortemente Anormale (103 video)

I video sono stati registrati con una risoluzione di 480p. La qualità dei video è stata tenuta bassa appositamente per non creare un dataset troppo grande in termini di memoria occupata e per assicurarsi che l'esperimento fosse riproducibile anche con telecamere meno precise. 



## Image Pre-processing

Successivamente all'acquisizione, si è passati alla fase di pre-processing nella quale i vide sono stati elaborati per semplificarne i dati rappresentati, mantenendo comunque le informazioni rilevanti. 
Esistono diverse tecniche per pre-processare le immagini. In questo esperimento si è deciso di utilizzare la libreria OpenPose. 

### OpenPose

OpenPose è una libreria opensource per la stima della posizione umana. Propone un metodo basato su una rappresentazione non parametrica, chiamata Part Affinity Fields (PAFs), per imparare ad associare parti del corpo con gli individui nell'immagine [[7]](#7).  A differenza delle altre soluzioni, OpenPose utilizza un approccio bottom-up, prima rileva tutte le parti del corpo presenti nell'immagine e poi le associa agli individui.
Il processo di rilevamento delle immagini avviene in 3 fasi: 

+ **Stage 0**: Viene utilizzata VGGNet per creare una mappa delle feature dell'immagine di input. VGGNet è una rete convoluzionale proposta da K. Simonyan e A. Zisserman nel paper “Very Deep Convolutional Networks for Large-Scale Image Recognition”. Il modello ha raggiunto il 92.7% di accuratezza nei test su image-net, un dataset contenente più di 14 milioni di immagini, appartenenti a 1000 classi. 
+ **Stage 1** : viene utilizzata una rete convoluzionale a 2 branch e a più stadi, dove il primo branch predice un insieme di mappe di confidenza 2D delle posizioni delle parti del corpo (per esempio il gomito, il ginocchio ecc...). Il secondo branch predice un insieme di campi vettoriali 2D di affinità delle parti, che codificano il grado di associazione tra le parti
+ **Stage 2**: Le mappe di confidenza e affinità sono analizzate tramite algoritmi greedy per produrre i punti chiave 2D per tutte le persone nell'immagine.

L'input è una immagine RGB. L'architettura multi-stage delle Reti Neurali Convoluzionali (CNN) predice prima l'insieme di PAFs, i campi vettoriali 2D, e le mappe di confidenza di rilevamento, che indicano la probabilità che una particolare parte del corpo possa essere localizzata in un determinato pixel. La figura mostra il procedimento seguito. 

Il tool è disponibile gratuitamente e può essere utilizzato su differenti piattaforme hardware e software. E' possibile personalizzare alcune impostazioni come la sorgente di input, che può essere una immagine, un video oppure la webcam. 
Una volta che il video è stato acquisito, OpenPose restituisce un file in formato JSON per ogni frame del video, contenente le coordinate 2D di ogni keypoint rilevato e la rispettiva confidenza nell'affermare che quel keypoint sia in quell'esatto pixel. 

Nel paper di riferimento, viene dimostrato come un algoritmo di parsing greedy è sufficiente per produrre una rappresentazione della posa di alta qualità, conservando l'efficienza indipendentemente dal numero di persone.

I keypoint rilevati sono 25 e sono i seguenti:

0. Nose
1. Neck
2. Right Shoulder
3. Right Elbow
4. Right Wrist
5. Left Shoulder
6. Left Elbow
7. Left Wrist
8. Middle Hip
9. Right Hip
10. Right Knee
11. Right Ankle
12. Left Hip
13. Left Knee
14. Left Ankle
15. Right Eye
16. Left Eye
17. Right Ear
18. Left Ear
19. Left Big Toe
20. Left Small Toe
21. Left Heel
22. Right Big Toe
23. Right Small Toe
24. Right Heel



## Creazione delle feature

L'output di Openpose può essere salvato in un vettore a 4 dimensioni (video, frame, keypoints, coordinate)

I video hanno tutti lunghezza diversa, si è scelto quindi di prendere in considerazione solo i primi 100 frame. 

A questo punto i dati sarebbero già pronti per poter alleare la rete neurale.
Il problema di questa rappresentazione è che è strettamente dipendente dal modo in cui sono stati registrati i video: le coordinate (x, y) dipendono dalla distanza fra la telecamera e il soggetto ripreso e dalla sua altezza. Essendo le camminate effettuate tutte dalla stessa persona, un approccio di questo genere avrebbe portato buoni risultati sul training set e sul validation set, ma non sarebbe stato in grado di generalizzare nel momento in cui gli fosse stato richiesto di classificare il video di una camminata registrata in condizioni e con individui diversi. 
L'approccio adottato è stato quello di calcolare per ogni frame di ogni video, gli angoli creati dal movimento degli arti, come per esempio l'angolo del gomito e del ginocchio. 
Dati 3 keypoints A, B e C, è possibile calcolare l'angolo $A\hat{B}C$ come: 

$$ angolo = \cos^{-1}(\frac{\overrightarrow{AB} \ · \ \overrightarrow{BC}}{|\overrightarrow{AB}| \ · \ |\overrightarrow{BC}| }) $$. 

Dati i 25 keypoints, sono stati scelti gli angoli calcolati sulle le seguenti terne: 

(0, 1, 8), (0, 1, 2), (0, 1, 5), (1, 2, 3), (2, 3, 4), (1, 5, 6), (5, 6, 7),  (1, 12, 13),  (1, 9, 10),  (8, 9, 10),  (8, 12, 13),  (9, 10, 11),  (12, 13, 14),  (10, 11, 22),  (13, 14, 19), (0, 8, 11),  (0, 8, 14),  (1, 8, 11),  (1, 8, 14)

Sono stati valutati gli angoli che evidenziavano maggiormente le differenze fra una camminata normale e una anomala.

Questa soluzione porta ad una diminuzione della dimensionalità del vettore da 4 a 3 dimensioni, e di conseguenza ad un dataset più leggero. Permette inoltre di avere features che siano indipendenti dal soggetto registrato e dalla telecamera utilizzata.

Il dataset definitivo è un vettore 3d della forma (video, frame, angolo)

Dati i 322 video registrati, possiamo notare come i dati da elaborare inizialmente fossero 322 * 100 * 25 * 2 = 1.610.000, mentre con la nuova soluzione 322 * 100 * 19  = 611.000. 



## Classificazione



 

#### Funzione di loss

La funzione di loss sceltà e la categoricall cross entropy, che la funzione di loss di default per i problemi di classificazione multi classe con singola label di output. 
La funzione calcola l'errore eseguendo la somma: 
$$ Loss = - \sum_{i = 1}^{output\ size} y_i · log (\hat{y}_i)$$
Dove $\hat{y}_i$ rappresenta l'i-esimo scalare nei valori di output,  mentre $y_i$ è l'i-esimo valore osservato.  Output size corrisponde al numero di valori di output del modello. 

Questa funzione si è dismostrata una buona misura di quanto due distribuzioni di probabilità discrete siano distinguibili l'una dall'altra. 
Il segno meno assicura che la perdita diventi più piccola quando le distribuzioni si avvicinano l'una all'altra. 



## Risultati

## Conclusioni e lavori futuri

###### 

## References

<a id="1">[1]</a> Gait disorders in adults and the elderly
<a id="2">[2]</a> Gait Analysis Methods: An Overview of Wearable and Non-Wearable Systems, Highlighting Clinical Applications
<a id="3">[3]</a> Estimation of Spatial-Temporal Gait Parameters Using a Low-Cost Ultrasonic Motion Analysis System
<a id="4">[4]</a> Kinetic gait analysis using a low-cost insole
<a id="5">[5]</a> Your Floor Knows Where You Are: Sensing and Acquisition of Movement Data
<a id="6">[6]</a> Deep Learning for Monitoring of Human Gait: A Review
<a id="7">[7]</a> OpenPose
<a id="8">[8]</a> I. Goodfellow, Y. Bengio, and A. Courville, Deep Learning. MIT Press, 2016, http: //www.deeplearningbook.org
<a id="9">[9]</a> Rosenblatt, F. 1957. The Perceptron — a perceiving and recognizing automaton.
<a id="10">[10]</a> McCulloch, W. S., and Pitts, W. 1943. A logical calculus of the ideas immanent in nervous activity. 
<a id="11">[11]</a> Learning representations by back-propagating errors
<a id="12">[12]</a> Computer Vision for Assistive Healthcare, chapter 5.
<a id="13">[13]</a> Dropout: A simple way to prevent neural networks from overfitting
<a id="14">[14]</a> Deep learnign with python. Francois Chollet
<a id="15">[15]</a> Gait speed as an incremental predictor of mortality and major morbidity in elderly patients undergoing cardiac surgery



